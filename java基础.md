# Object oriented 

## javase

### 对象，什么是对象？

	对象是自成一体的实体，仅包含属性和行为，不包含其他任何内容  

精心编写的对象：

*	拥有明确的边界定义
*	执行一组有限的活动
*	仅知道他的数据和他完成活动所需的任何其他对象

本质上，对象是一个离散的实体，

### 面向对象
	
	状态：对象的状态任何时刻都由他的属性值来表示

### 面向对象六大原则

	* 单一职责:高内聚，低耦合
	* 开闭原则:扩展开放，修改关闭
	* 里氏替换
	* 依赖倒置
	* 接口隔离
	* 迪米特 

### 面向对象设计

	如何将发生变化的东西与保持不变的东西分离开


### 语法基础

#### final

	三种应用场合：变量、方法、类（非抽象）

1，final类不能被继承，没有子类，final类中的方法默认是final
2，final方法不能被子类的方法覆盖，可以被继承。
3，final修饰成员变量，只能被赋值一次，赋值后值不再改变。
4，final参数，可以读取该参数的值，但是不能修改其值。

#### static

	应用场合：变量、方法、类

1，被static修饰的成员变量和成员方法，独立于该类的任何对象。
2，任何静态方法中不能出现this和super关键字。
	


#### transient

	1，一旦变量被transient修饰，变量就成为对象中不可持久化的一部分
	2，transient只能修饰变量而且是自定义变量，而且该类必须实现Serializable接口
	3，被transient修饰的变量不能再被序列化，一个静态变量不管是否被transient修饰都不能序列化

	对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自
	动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal
	方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。因此第二个例子输出的是变
	量content初始化的内容，而不是null。

#### 枚举

##### 什么是枚举

	用来将一组类似的值包含到一种类型中。

##### 应用场景



### ==、equals、hashcode

什么是哈希？

	哈希是将任意长度的输入转换成固定长度的输出，输出的值就是散列值。这是一种“压缩转换”。

哈希表

	哈希表有多种不同的实现方法，比如拉链法

	它是根据关键码值直接进行访问的数据结构

	
什么是散列法

	根据元素的特征计算元素数组下标的方法。

	除法（取模）散列法
	平方散列法
	斐波那契散列法


### >>、<<、>>>
1，<<(左移),移几位相当于乘以几个2  
2，>>(右移),  
3，>>>(无符号右移),  忽略符号位，空位都以0补齐

### &、|、^、~
1，&(位与)，都是1得1，否则为0  
2，|(位或)，有一个是1就为1，否则为0  
3，^(异或)，相反为1，否则为0  
4，~(位非)，1为反是0,0为反是1  

### clone

浅拷贝：使用一个已知实例对新建实例的成员变量逐个赋值。  
深拷贝：当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创建新实例，并且初始化为形式参数实例值

延迟拷贝：

总结一句话，浅拷贝不能拷贝引用对象，深拷贝既能拷贝基础类型，也能拷贝引用对象，



### 内部类

成员内部类，局部内部类，匿名内部类，静态内部类

每个内部类都能独立地继承一个接口实现，无论外围类是否已经继承了某一个接口，对内部类都没影响。

内部类和外部类并没有is-a的关系，而是一个独立的实体。

使用内部类，可以更好的解决多重继承的问题？


### 集合



### IO



### NIO

NoN-Blocking IO：同步非阻塞的I/O模型


通道和缓冲区

NIO库中的所有操作都是在缓冲区操作的，缓冲区本质是一个数组。

通道与流的区别在于通道是双向的，而流是在单向的。


### 多线程

```多线程的实现方式```
	
	继承Thread
	实现Runnable
	Callable和Future

前两种无法获取执行后的结果，Callable和Future在执行完任务之后可以获取执行后的结果


```线程栈模型```
	
	线程启动会创建一个属于自己的线程栈模型

```线程状态的转换：```

	sleep()：
	yield()：作用是暂停当前正在执行的线程对象，让出处理器资源，让处理器执行其他线程,当前线程变成可运行状态
	join():线程b加入到线程a的尾部，线程a未执行完毕之前，线程b不能工作
	warn：线程优先级在实际应用中并不能按你预期来执行

```线程同步与锁```



```线程交互```




## 共享变量

	在多个线程之间能够被共享的变量

## 锁
两种主要特性：

	1，互斥性：一次只允许一个线程持有某个特定的锁
	2，可见性

## 内置锁

### volatile
轻量级的synchronize，主要用来修饰变量，保证共享变量的“可见性”，可见性的意思是：当一个线程修改一个共享变量时，另外一个线程可以读到修改的值

#### synchronized

	可以修饰普通方法、静态方法、形成代码块
	1，普通同步方法，锁是当前实例对象
	2，静态同步方法，锁是当前类的class对象
	3，同步方法块，锁是括号里的对象

java对象头：


monitor：

java怎么样实现原子操作（不可被中断的一个或一系列操作）？

	锁和循环CAS操作
	
CAS：Compare And Swap,比较并交换

非阻塞算法：一个线程的失败或挂起不应该影响其他线程的失败或挂起的算法

无锁 -> 偏向锁 -> 轻量锁 -> 重量锁

## 由java.util.concurrent.locks.Lock派生出来的锁




## Map

### HashMap、HashTable、ConCurrentHashMap
HashTable是线程安全的，但是效率比较低下，原因是，所有访问HashTable的线程都必须竞争同一把锁。  
如果容器里面有多把锁，每一把锁用于锁容器中的一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，提高效率